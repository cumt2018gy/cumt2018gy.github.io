(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{360:function(a,s,t){"use strict";t.r(s);var e=t(43),h=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"说一下-map-的分类和常见的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下-map-的分类和常见的情况"}},[a._v("#")]),a._v(" 说一下 map 的分类和常见的情况")]),a._v(" "),t("p",[a._v("Java为数据结构中的映射定义了一个接口  java.util.Map ；它有四个实现类，分别是")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("HashMap  Hashtable  LinkedHashMap 和   TreeMap.\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("Map主要用于存储健值对，根据键得到值，因此"),t("strong",[a._v("不允许键重复")]),a._v("（重复了覆盖了），但"),t("strong",[a._v("允许值重复")]),a._v("。")]),a._v(" "),t("h2",{attrs:{id:"hashmap是一个最常用的map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap是一个最常用的map"}},[a._v("#")]),a._v(" Hashmap是一个最常用的Map")]),a._v(" "),t("p",[a._v("它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。"),t("strong",[a._v("HashMap最多只允许一条记录的键为Null")]),a._v("；允许多条记录的值为Null："),t("strong",[a._v("HashMap不支持线程的同步")]),a._v("，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap.")]),a._v(" "),t("h2",{attrs:{id:"hashtable与hashmap类似"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable与hashmap类似"}},[a._v("#")]),a._v(" Hashtable与HashMap类似")]),a._v(" "),t("p",[a._v("它维承自Dictionary类，不同的是："),t("strong",[a._v("它不允许记录的键或者值为空")]),a._v("：它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。")]),a._v(" "),t("h2",{attrs:{id:"linkedhlashmap-是hashmap一个子类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhlashmap-是hashmap一个子类"}},[a._v("#")]),a._v(" LinkedHlashMap 是HashMap一个子类")]),a._v(" "),t("p",[t("strong",[a._v("保存了记录的插入顺序")]),a._v("，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。")]),a._v(" "),t("h2",{attrs:{id:"treemap实现sortmap接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap实现sortmap接口"}},[a._v("#")]),a._v(" TreeMap实现SortMap接口")]),a._v(" "),t("p",[a._v("能够把它保存的"),t("strong",[a._v("记录根据键排序")]),a._v("，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。")]),a._v(" "),t("p",[a._v("一般情况下，我们用的最多的是HashMap，在Map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同，那么用LinkedlashMap可以实现，它还可以按读取顺序来排列.")]),a._v(" "),t("h2",{attrs:{id:"hashmap是一个最常用的map-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap是一个最常用的map-2"}},[a._v("#")]),a._v(" HashMap是一个最常用的Map")]),a._v(" "),t("p",[a._v("它根据"),t("strong",[a._v("键的hashCode值存储数据")]),a._v("，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL.")]),a._v(" "),t("p",[t("strong",[a._v("HashMap不支持线程同步")]),a._v("，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。")]),a._v(" "),t("p",[t("strong",[a._v("Hashtable与HashMap类似")]),a._v("，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。")]),a._v(" "),t("p",[t("strong",[a._v("LinkedlashMap保存了记录的插入顺序")]),a._v("，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢。")]),a._v(" "),t("p",[t("strong",[a._v("TreeMap能够把它保存的记录根据键排序")]),a._v("，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的.")]),a._v(" "),t("blockquote",[t("p",[a._v("最后修改时间 2020/6/17")])])])}),[],!1,null,null,null);s.default=h.exports}}]);