(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{357:function(t,s,a){"use strict";a.r(s);var e=a(43),h=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"为什么重写-equals-还要重写-hashcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么重写-equals-还要重写-hashcode"}},[t._v("#")]),t._v(" 为什么重写 equals 还要重写 hashcode")]),t._v(" "),a("h4",{attrs:{id:"回答："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回答："}},[t._v("#")]),t._v(" 回答：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/06/tgSTZ4.png",alt:"img"}})]),t._v(" "),a("h4",{attrs:{id:"理解："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解："}},[t._v("#")]),t._v(" 理解：")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"转载："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转载："}},[t._v("#")]),t._v(" 转载：")]),t._v(" "),a("p",[t._v("原文链接：https://blog.csdn.net/xl_1803/article/details/80445481")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("大家都知道，equals 和hashcode 是java.lang.Object类的两个重要的方法，在实际应用中常常需要重写这两个方法，但至于为什么重写这两个方法很多人都搞不明白，以下是我的一些个人理解。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/06/tcz69x.png",alt:"img"}})]),t._v(" "),a("p",[t._v("这是Object类关于这两个方法的源码，可以看出，Object类默认的equals 比较规则就是比较两个对象的内存地址。而hashcode是本地方法，java的内存是安全的，因此无法根据散列码得到对象的内存地址，但实际上，hashcode是根据对象的内存地址经哈希算法得来的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/06/tczs41.png",alt:"img"}})]),t._v(" "),a("p",[t._v("上图展示了Student类的重写后的equals方法和hashcode方法，建议大家用 idea 自动生成，尽量不要自己敲因为很有可能会出错。")]),t._v(" "),a("p",[t._v("现在有两个Student对象：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('Student s1=new Student("小明",18);\n\nStudent s2=new Student("小明",18);\n')])])]),a("p",[t._v("此时 s1.equals(s2) 一定返回true")]),t._v(" "),a("p",[t._v("假如只重写 equals 而不重写 hashcode ，那么Student类的 hashcode 方法就是Object默认的hashcode 方法，由于默认的 hashcode 方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的  hashcode  不一定相等。")]),t._v(" "),a("p",[t._v("然而重写了 equals，且 s1.equals(s2) 返回true，根据 hashcode 的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写 equals一定要重写 hashcode，而且从Student类重写后的 hashcode 方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。")]),t._v(" "),a("p",[t._v("以下是关于 hashcode 的一些规定：")]),t._v(" "),a("p",[t._v("两个对象相等，hashcode一定相等")]),t._v(" "),a("p",[t._v("两个对象不等，hashcode不一定不等")]),t._v(" "),a("p",[t._v("hashcode相等，两个对象不一定相等")]),t._v(" "),a("p",[t._v("hashcode不等，两个对象一定不等")]),t._v(" "),a("blockquote",[a("p",[t._v("最后修改时间 2020/6/17")])])])}),[],!1,null,null,null);s.default=h.exports}}]);